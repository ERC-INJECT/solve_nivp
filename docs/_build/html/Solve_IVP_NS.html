
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Solve_IVP_NS package &#8212; solve_ivp_ns March 26, 2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-Solve_IVP_NS">
<span id="solve-ivp-ns-package"></span><h1>Solve_IVP_NS package<a class="headerlink" href="#module-Solve_IVP_NS" title="Permalink to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="Solve_IVP_NS.solve_ivp_ns">
<span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.</span></span><span class="sig-name descname"><span class="pre">solve_ivp_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_span</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'composite'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'VI'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection_opts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_opts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.solve_ivp_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>A high-level function to solve an ODE with optional projection and custom solver settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
ODE function fun(t, y).</p></li>
<li><p><strong>t_span</strong> – (float, float)
Start and end times.</p></li>
<li><p><strong>y0</strong> – array_like
Initial condition.</p></li>
<li><p><strong>method</strong> – str
Integration method name, e.g. ‘composite’, ‘backward_euler’, ‘bdf’, etc.</p></li>
<li><p><strong>projection</strong> – str or None
Projection type, e.g. ‘coulomb’, ‘sign’, ‘identity’, or None for no projection.</p></li>
<li><p><strong>solver</strong> – str
Nonlinear solver method, e.g. ‘VI’, ‘newton_raphson’, ‘root’, etc.</p></li>
<li><p><strong>projection_opts</strong> – dict
Extra keyword arguments for the projection class (e.g. friction parameters).</p></li>
<li><p><strong>solver_opts</strong> – dict
Extra keyword arguments for the ImplicitEquationSolver.</p></li>
<li><p><strong>adaptive</strong> – bool
Whether to use adaptive stepping.</p></li>
<li><p><strong>atol</strong> – float
Tolerances for adaptive stepping.</p></li>
<li><p><strong>rtol</strong> – float
Tolerances for adaptive stepping.</p></li>
<li><p><strong>h0</strong> – float
Initial step size.</p></li>
<li><p><strong>component_slices</strong> – list of slices or None
For partitioning the state vector.</p></li>
<li><p><strong>verbose</strong> – bool
Print debug info if True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(t_vals, y_vals, h_vals, fk_vals, solver_info)</dt><dd><p>Arrays of time, solution, step sizes, residuals, and solver diagnostics.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-Solve_IVP_NS.ODESolver">
<span id="solve-ivp-ns-odesolver-module"></span><h2>Solve_IVP_NS.ODESolver module<a class="headerlink" href="#module-Solve_IVP_NS.ODESolver" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.ODESolver.</span></span><span class="sig-name descname"><span class="pre">ODESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>ODESolver performs integration of an ODE system over a specified time span.</p>
<p>The solver iteratively advances the solution using either adaptive or fixed time steps.
It records the time points, state vectors, step sizes, and diagnostic error information.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.system">
<span class="sig-name descname"><span class="pre">system</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.system" title="Permalink to this definition">¶</a></dt>
<dd><p>The ODE system instance (e.g., an instance of ODESystem).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.t0">
<span class="sig-name descname"><span class="pre">t0</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.t0" title="Permalink to this definition">¶</a></dt>
<dd><p>The initial time.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.tf">
<span class="sig-name descname"><span class="pre">tf</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.tf" title="Permalink to this definition">¶</a></dt>
<dd><p>The final time.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.h_initial">
<span class="sig-name descname"><span class="pre">h_initial</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.h_initial" title="Permalink to this definition">¶</a></dt>
<dd><p>The initial time step size.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.t_values">
<span class="sig-name descname"><span class="pre">t_values</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.t_values" title="Permalink to this definition">¶</a></dt>
<dd><p>List of time points.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.y_values">
<span class="sig-name descname"><span class="pre">y_values</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.y_values" title="Permalink to this definition">¶</a></dt>
<dd><p>List of state vectors corresponding to each time step.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.h_values">
<span class="sig-name descname"><span class="pre">h_values</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.h_values" title="Permalink to this definition">¶</a></dt>
<dd><p>List of step sizes taken.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.error_estimates">
<span class="sig-name descname"><span class="pre">error_estimates</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.error_estimates" title="Permalink to this definition">¶</a></dt>
<dd><p>List of diagnostic tuples (solver_error, success flag, iteration count).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.fk">
<span class="sig-name descname"><span class="pre">fk</span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.fk" title="Permalink to this definition">¶</a></dt>
<dd><p>List of derivative/residual values computed during integration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESolver.ODESolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#Solve_IVP_NS.ODESolver.ODESolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate the ODE system from the initial to the final time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>t_values: Array of time points.</p></li>
<li><p>y_values: Array of state vectors at each time point.</p></li>
<li><p>h_values: Array of step sizes used.</p></li>
<li><p>fk: Array of derivative/residual values (as objects to support varying sizes).</p></li>
<li><p>error_estimates: List of diagnostic tuples (solver_error, success flag, iteration count).</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-Solve_IVP_NS.ODESystem">
<span id="solve-ivp-ns-odesystem-module"></span><h2>Solve_IVP_NS.ODESystem module<a class="headerlink" href="#module-Solve_IVP_NS.ODESystem" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESystem.ODESystem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.ODESystem.</span></span><span class="sig-name descname"><span class="pre">ODESystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#Solve_IVP_NS.integrations.IntegrationMethod" title="Solve_IVP_NS.integrations.IntegrationMethod"><span class="pre">IntegrationMethod</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'backward_euler'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adaptive</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.ODESystem.ODESystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Encapsulates an ordinary differential equation (ODE) system together with a numerical integrator.</p>
<p>This class sets up the system using an ODE function, initial state, and a selected integration method.
It supports both fixed-step and adaptive-step integration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
Function defining the ODE, with signature fun(t, y).</p></li>
<li><p><strong>y0</strong> – array_like
Initial state vector.</p></li>
<li><p><strong>method</strong> – str or IntegrationMethod, default ‘backward_euler’
The integration method to use. This can be a string specifying the method (e.g., ‘backward_euler’,
‘trapezoidal’, ‘theta’, ‘composite’, ‘bdf’) or an instance of an IntegrationMethod.</p></li>
<li><p><strong>a</strong> – float, default 1.0
Parameter used for some integrators (e.g., CompositeMethod).</p></li>
<li><p><strong>adaptive</strong> – bool, default False
Flag indicating whether to use adaptive time stepping.</p></li>
<li><p><strong>atol</strong> – float, default 1e-6
Absolute tolerance for adaptive stepping.</p></li>
<li><p><strong>rtol</strong> – float, default 1e-3
Relative tolerance for adaptive stepping.</p></li>
<li><p><strong>component_slices</strong> – list of slice objects, optional
Slices that partition the state vector into components (used for error estimation).</p></li>
<li><p><strong>verbose</strong> – bool, default False
If True, enables verbose logging during stepping.</p></li>
<li><p><strong>A</strong> – optional (e.g., np.array)
A matrix parameter to pass to the integration method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESystem.ODESystem.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.ODESystem.ODESystem.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Take one integration step using either adaptive or fixed stepping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – float
Current time.</p></li>
<li><p><strong>h</strong> – float
Time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The integration step results, which vary depending on the stepping mode.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESystem.ODESystem.step_adaptive">
<span class="sig-name descname"><span class="pre">step_adaptive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.ODESystem.ODESystem.step_adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one adaptive-step integration using the adaptive stepper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – float
Current time.</p></li>
<li><p><strong>h</strong> – float
Proposed time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result of the adaptive stepping procedure.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.ODESystem.ODESystem.step_fixed">
<span class="sig-name descname"><span class="pre">step_fixed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.ODESystem.ODESystem.step_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one fixed-step integration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> – float
Current time.</p></li>
<li><p><strong>h</strong> – float
Fixed time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>y_new : array_like, updated state vector.
f_new : array_like, derivative evaluated at the new state.
solver_error : float, error reported by the integrator.
success : bool, solver success flag.
iterations : int, number of iterations taken by the solver.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A tuple containing</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-Solve_IVP_NS.adaptive_integrator">
<span id="solve-ivp-ns-adaptive-integrator-module"></span><h2>Solve_IVP_NS.adaptive_integrator module<a class="headerlink" href="#module-Solve_IVP_NS.adaptive_integrator" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.adaptive_integrator.AdaptiveStepping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.adaptive_integrator.</span></span><span class="sig-name descname"><span class="pre">AdaptiveStepping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integrator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_up</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_down</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_error_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.adaptive_integrator.AdaptiveStepping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Adaptive time-stepping controller for non-BDF integrators using a full-step/two-half-step strategy.</p>
<p>This class estimates the local error of a proposed step by comparing a single full step
with two successive half steps. Based on the computed error, the step size is adapted for
the next integration step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>integrator</strong> – object
An integrator instance that implements a ‘step’ method.</p></li>
<li><p><strong>component_slices</strong> – list of slice objects, optional
Slices to partition the state vector into components for error estimation.</p></li>
<li><p><strong>atol</strong> – float, default 1e-6
Absolute tolerance for error estimation.</p></li>
<li><p><strong>rtol</strong> – float, default 1e-3
Relative tolerance for error estimation.</p></li>
<li><p><strong>h0</strong> – float, default 1e-2
Initial time step size.</p></li>
<li><p><strong>h_min</strong> – float, default 1e-5
Minimum allowable time step.</p></li>
<li><p><strong>h_max</strong> – float, default 1e3
Maximum allowable time step.</p></li>
<li><p><strong>h_up</strong> – float, default 2.0
Maximum factor for increasing the step size.</p></li>
<li><p><strong>h_down</strong> – float, default 0.6
Factor for decreasing the step size.</p></li>
<li><p><strong>q</strong> – float, default 0.5
Order exponent used in the step size control.</p></li>
<li><p><strong>verbose</strong> – bool, default False
If True, prints diagnostic messages during stepping.</p></li>
<li><p><strong>skip_error_indices</strong> – list of int, optional
Component indices to skip during error estimation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.adaptive_integrator.AdaptiveStepping.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.adaptive_integrator.AdaptiveStepping.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one adaptive time step using a full-step and two half-step strategy.</p>
<dl class="simple">
<dt>The method:</dt><dd><ol class="arabic simple">
<li><p>Computes a full-step using the integrator.</p></li>
<li><p>Computes two half-steps and compares the result with the full-step.</p></li>
<li><p>Estimates the error based on the difference between the full-step and half-step solutions.</p></li>
<li><p>Adjusts the time step size accordingly.</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
Function representing the right-hand side (derivative) of the ODE.</p></li>
<li><p><strong>t</strong> – float
Current time.</p></li>
<li><p><strong>y</strong> – array_like
Current state vector.</p></li>
<li><p><strong>h</strong> – float
Proposed time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>array_like</dt><dd><p>New state computed from the two half-steps.</p>
</dd>
<dt>fk_new<span class="classifier">array_like</span></dt><dd><p>Derivative evaluated at the new state.</p>
</dd>
<dt>h_new<span class="classifier">float</span></dt><dd><p>Adapted time step for the next step.</p>
</dd>
<dt>E<span class="classifier">float</span></dt><dd><p>Estimated scaled error.</p>
</dd>
<dt>success<span class="classifier">bool</span></dt><dd><p>True if the error is acceptable (E ≤ 1), False otherwise.</p>
</dd>
<dt>solver_error<span class="classifier">float</span></dt><dd><p>Error reported by the integrator’s solver for the full-step.</p>
</dd>
<dt>solver_iterations<span class="classifier">int</span></dt><dd><p>Number of iterations taken by the integrator for the full-step.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>y_new</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-Solve_IVP_NS.integrations">
<span id="solve-ivp-ns-integrations-module"></span><h2>Solve_IVP_NS.integrations module<a class="headerlink" href="#module-Solve_IVP_NS.integrations" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.BackwardEuler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.integrations.</span></span><span class="sig-name descname"><span class="pre">BackwardEuler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.BackwardEuler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.integrations.IntegrationMethod" title="Solve_IVP_NS.integrations.IntegrationMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrationMethod</span></code></a></p>
<p>Implements the Backward Euler implicit integration method.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.BackwardEuler.solver">
<span class="sig-name descname"><span class="pre">solver</span></span><a class="headerlink" href="#Solve_IVP_NS.integrations.BackwardEuler.solver" title="Permalink to this definition">¶</a></dt>
<dd><p>ImplicitEquationSolver
A solver instance used to solve the implicit equations.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.BackwardEuler.A">
<span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#Solve_IVP_NS.integrations.BackwardEuler.A" title="Permalink to this definition">¶</a></dt>
<dd><p>np.array or None
A matrix used in the formulation of the method. If None, the identity matrix is used.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.BackwardEuler.use_identity">
<span class="sig-name descname"><span class="pre">use_identity</span></span><a class="headerlink" href="#Solve_IVP_NS.integrations.BackwardEuler.use_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>bool
Flag to indicate whether to use the identity matrix.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.BackwardEuler._ID_CACHE">
<span class="sig-name descname"><span class="pre">_ID_CACHE</span></span><a class="headerlink" href="#Solve_IVP_NS.integrations.BackwardEuler._ID_CACHE" title="Permalink to this definition">¶</a></dt>
<dd><p>dict
Class-level cache for identity matrices to avoid recomputation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.BackwardEuler.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.BackwardEuler.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Take one Backward Euler step for the ODE.</p>
<dl class="simple">
<dt>Formulates the implicit equation:</dt><dd><p>A &#64; ((y_new - y) / h) - fun(t+h, y_new) = 0</p>
</dd>
</dl>
<p>and solves for y_new.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
The function defining the ODE.</p></li>
<li><p><strong>t</strong> – float
The current time.</p></li>
<li><p><strong>y</strong> – np.array
The current state.</p></li>
<li><p><strong>h</strong> – float
The time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated state computed by the solver.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.CompositeMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.integrations.</span></span><span class="sig-name descname"><span class="pre">CompositeMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.CompositeMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.integrations.IntegrationMethod" title="Solve_IVP_NS.integrations.IntegrationMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrationMethod</span></code></a></p>
<dl class="simple">
<dt>Implements a composite integration method that combines two steps:</dt><dd><ol class="arabic simple">
<li><p>A half-step using the Trapezoidal method.</p></li>
<li><p>A full step using a modified Backward Euler method.</p></li>
</ol>
</dd>
</dl>
<p>The composite method first advances the solution halfway in time, then uses this intermediate
value to compute the final step.</p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.CompositeMethod.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.CompositeMethod.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Take one composite integration step for the ODE.</p>
<dl class="simple">
<dt>The composite step is broken into two parts:</dt><dd><ol class="arabic simple">
<li><p>Compute an intermediate solution y_half at t + h/2 using the Trapezoidal method.</p></li>
<li><p>Compute the final solution y_new at t + h using a Backward Euler step with a specific implicit equation:
(3*y_new - 4*y_half + y)/h - fun(t+h, y_new) = 0</p></li>
</ol>
</dd>
</dl>
<p>If the first sub-step fails (i.e., the solver does not converge), the method returns early.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
The function defining the ODE.</p></li>
<li><p><strong>t</strong> – float
The current time.</p></li>
<li><p><strong>y</strong> – np.array
The current state.</p></li>
<li><p><strong>h</strong> – float
The time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(y_new, Fk_new, err_new, overall_success, total_iters)</dt><dd><p>y_new: The updated state.
Fk_new: The residual or function value from the second solver.
err_new: The error estimate from the second solver.
overall_success: Boolean flag indicating if both sub-steps were successful.
total_iters: Combined iteration count from both sub-steps.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.IntegrationMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.integrations.</span></span><span class="sig-name descname"><span class="pre">IntegrationMethod</span></span><a class="headerlink" href="#Solve_IVP_NS.integrations.IntegrationMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for integration methods.</p>
<p>Classes derived from IntegrationMethod must implement the <cite>step</cite> method,
which advances the solution of an ODE from time t to t+h.</p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.IntegrationMethod.step">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.IntegrationMethod.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the solution of an ODE by one time step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
The function defining the ODE (dy/dt = fun(t, y)).</p></li>
<li><p><strong>t</strong> – float
The current time.</p></li>
<li><p><strong>y</strong> – np.array
The current state vector.</p></li>
<li><p><strong>h</strong> – float
The time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new state after taking the step (and possibly additional diagnostic info).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.ThetaMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.integrations.</span></span><span class="sig-name descname"><span class="pre">ThetaMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.ThetaMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.integrations.BackwardEuler" title="Solve_IVP_NS.integrations.BackwardEuler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardEuler</span></code></a></p>
<p>Implements the Theta integration method, a generalization of Backward Euler and Trapezoidal methods.</p>
<dl class="simple">
<dt>The method uses a parameter theta in [0, 1]:</dt><dd><ul class="simple">
<li><p>theta = 1 gives Backward Euler,</p></li>
<li><p>theta = 0.5 gives Trapezoidal method.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.ThetaMethod.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.ThetaMethod.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Take one Theta method step for the ODE.</p>
<dl class="simple">
<dt>Formulates the implicit equation:</dt><dd><p>A &#64; ((y_new - y) / h) - (theta * fun(t+h, y_new) + (1-theta)*fun(t, y)) = 0</p>
</dd>
</dl>
<p>and solves for y_new.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
The function defining the ODE.</p></li>
<li><p><strong>t</strong> – float
The current time.</p></li>
<li><p><strong>y</strong> – np.array
The current state.</p></li>
<li><p><strong>h</strong> – float
The time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated state computed by the solver.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.Trapezoidal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.integrations.</span></span><span class="sig-name descname"><span class="pre">Trapezoidal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.Trapezoidal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.integrations.BackwardEuler" title="Solve_IVP_NS.integrations.BackwardEuler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BackwardEuler</span></code></a></p>
<p>Implements the Trapezoidal (Crank-Nicolson) integration method.</p>
<p>Inherits the matrix handling from BackwardEuler.</p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.integrations.Trapezoidal.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.integrations.Trapezoidal.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Take one Trapezoidal method step for the ODE.</p>
<dl class="simple">
<dt>Formulates the implicit equation:</dt><dd><p>A &#64; ((y_new - y) / h) - 0.5*(fun(t, y) + fun(t+h, y_new)) = 0</p>
</dd>
</dl>
<p>and solves for y_new.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fun</strong> – callable
The function defining the ODE.</p></li>
<li><p><strong>t</strong> – float
The current time.</p></li>
<li><p><strong>y</strong> – np.array
The current state.</p></li>
<li><p><strong>h</strong> – float
The time step size.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated state computed by the solver.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-Solve_IVP_NS.nonlinear_solvers">
<span id="solve-ivp-ns-nonlinear-solvers-module"></span><h2>Solve_IVP_NS.nonlinear_solvers module<a class="headerlink" href="#module-Solve_IVP_NS.nonlinear_solvers" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.nonlinear_solvers.ImplicitEquationSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.nonlinear_solvers.</span></span><span class="sig-name descname"><span class="pre">ImplicitEquationSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'root'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_autodiff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autodiff_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'autograd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.66</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J_g_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.nonlinear_solvers.ImplicitEquationSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generic solver for the implicit equation F(y)=0.</p>
<dl class="simple">
<dt>This solver returns a tuple:</dt><dd><p>(y_new, Fk, error, success, iterations)</p>
</dd>
<dt>Supported methods:</dt><dd><ul class="simple">
<li><p>‘root’</p></li>
<li><p>‘newton_raphson’</p></li>
<li><p>‘PEG’</p></li>
<li><p>‘VI’</p></li>
<li><p>‘semismooth_newton’</p></li>
</ul>
</dd>
</dl>
<p>For the semismooth newton method, a projection operator (proj) and functions
g_func and J_g_func must be provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> – str, default ‘root’
The solver method.</p></li>
<li><p><strong>jacobian</strong> – callable, optional
A user-supplied function to compute the Jacobian.</p></li>
<li><p><strong>tol</strong> – float, default 1e-10
Convergence tolerance.</p></li>
<li><p><strong>max_iter</strong> – int, default 100
Maximum number of iterations.</p></li>
<li><p><strong>proj</strong> – object, optional
Projection operator (must implement .project and .tangent_cone).</p></li>
<li><p><strong>rho0</strong> – float, default 0.9
Parameter for VI/PEG methods.</p></li>
<li><p><strong>delta</strong> – float, default 0.7
Parameter for VI/PEG methods.</p></li>
<li><p><strong>component_slices</strong> – list, optional
List of slices for partitioning the state (required for some methods).</p></li>
<li><p><strong>use_autodiff</strong> – bool, default False
Whether to use automatic differentiation for Jacobian computation.</p></li>
<li><p><strong>autodiff_mode</strong> – str, default ‘autograd’
Which autodiff backend to use: ‘jax’ (if available) or ‘autograd’.</p></li>
<li><p><strong>L</strong> – float, default 0.9
Parameter used in VI line-search.</p></li>
<li><p><strong>Lmin</strong> – float, default 0.3
Lower bound parameter in VI line-search.</p></li>
<li><p><strong>nu</strong> – float, default 0.66
Factor used in VI line-search.</p></li>
<li><p><strong>lam</strong> – float, default 1.0
Parameter used in the semismooth function.</p></li>
<li><p><strong>g_func</strong> – callable, optional
Function used in semismooth newton (typically the integrator residual).</p></li>
<li><p><strong>J_g_func</strong> – callable, optional
User-provided Jacobian for g_func (if autodiff is not used).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.nonlinear_solvers.ImplicitEquationSolver.set_func">
<span class="sig-name descname"><span class="pre">set_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.nonlinear_solvers.ImplicitEquationSolver.set_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the function F(y) that is to be solved.
Attempt to set up autodifferentiation for the Jacobian.
If an error occurs (e.g. due to JAX tracer issues), fall back to numerical differentiation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.nonlinear_solvers.ImplicitEquationSolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.nonlinear_solvers.ImplicitEquationSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve F(y)=0 for y, starting from initial guess y0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(y_new, Fk, error, success, iterations)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-Solve_IVP_NS.projections">
<span id="solve-ivp-ns-projections-module"></span><h2>Solve_IVP_NS.projections module<a class="headerlink" href="#module-Solve_IVP_NS.projections" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.CoulombProjection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.projections.</span></span><span class="sig-name descname"><span class="pre">CoulombProjection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">con_force_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.CoulombProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.projections.Projection" title="Solve_IVP_NS.projections.Projection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Projection</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.CoulombProjection.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.CoulombProjection.project" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.CoulombProjection.tangent_cone">
<span class="sig-name descname"><span class="pre">tangent_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.CoulombProjection.tangent_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Build derivative matrix. We’ll store in a NumPy array for the linear solve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.IdentityProjection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.projections.</span></span><span class="sig-name descname"><span class="pre">IdentityProjection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.IdentityProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.projections.Projection" title="Solve_IVP_NS.projections.Projection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Projection</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.IdentityProjection.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.IdentityProjection.project" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.IdentityProjection.tangent_cone">
<span class="sig-name descname"><span class="pre">tangent_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.IdentityProjection.tangent_cone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.Projection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.projections.</span></span><span class="sig-name descname"><span class="pre">Projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.Projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.Projection.project">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.Projection.project" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.Projection.tangent_cone">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tangent_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.Projection.tangent_cone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.SignProjection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Solve_IVP_NS.projections.</span></span><span class="sig-name descname"><span class="pre">SignProjection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.SignProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Solve_IVP_NS.projections.Projection" title="Solve_IVP_NS.projections.Projection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Projection</span></code></a></p>
<dl class="simple">
<dt>Orthogonal projection onto the set:</dt><dd><p>K = { (y,w) :  w in sign(y) }.</p>
</dd>
</dl>
<p>i.e. y&gt;0 =&gt; w=+1, y&lt;0 =&gt; w=-1, y=0 =&gt; w in [-1,1].
Only the w-components are modified; the y-components remain unchanged.</p>
<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.SignProjection.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.SignProjection.project" title="Permalink to this definition">¶</a></dt>
<dd><p>If y&gt;0 =&gt; w=+1, y&lt;0 =&gt; w=-1, else clip w to [-1,1].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Solve_IVP_NS.projections.SignProjection.tangent_cone">
<span class="sig-name descname"><span class="pre">tangent_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">candidate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Solve_IVP_NS.projections.SignProjection.tangent_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative: if y!=0 =&gt; w is constant =&gt; derivative=0
if y==0 =&gt; derivative=1 if w in(-1,1), else0</p>
</dd></dl>

</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">solve_ivp_ns</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, David Riley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/Solve_IVP_NS.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>